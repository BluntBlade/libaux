# 字符串模块

## 需求
字符串是最为基础的数据类型，应用广泛。C语言对字符串的定义非常原始，逐渐落后于现代软件编程的需要，常常造成不必要甚至严重的问题（性能、安全等）。设计一种定长、不可变的字符串类型，配以合适的函数，在满足大部分需求的同时，降低对标准C函数的信赖，降低安全问题的发生概率，显得越来越迫切。

## 设计要点
1. 固定长度：避免频繁计算长度，快速返回串长度或字符数；
2. 不可变：字符串一经生成则不再变化，如调用函数改变内容将生成新的字符串；
3. 支持切片：返回给定字符范围的切片（Slice），减少生成新串的需求；
4. 兼容C字符串：保留 NUL 字符作为终止标志。需要返回切片的内存地址时生成新串来追加 NUL 字符。
5. 极小内存：内存布局尽量紧凑，减少资源消耗；
6. 支持内嵌：可将字符串内嵌到其它数据结构中；
7. 引用计数：返回指向字符串或切片的指针时，使用引用计数进行统计和管理。当字符串不再被引用时，自动释放内存；
8. 多种编码：在内部记录字符串所使用的编码格式，调用对应函数进行处理。

## 内存布局
分为两种格式，A)**字符串**表示一个定长的字符串（标志位置0），B)**切片**表示对某个字符范围的引用（标志位置1）。均支持最长 2^32 个字节。

```
typedef struct NSTR {
    uint32_t is_slice:1;        // 类型标志位：0 表示字符串，1 表示切片
    uint32_t need_free:1;       // 是否释放内存：0 表示不需要，1 表示需要
    uint32_t encoding:8;        // 编码方案代号，最多支持 255 种编码
    uint32_t unused:22;         // 未使用位域，保持边界对齐

    uint32_t chars;             // 编码后的字符个数
    uint32_t bytes;             // 占用内存字节数

    union {
        uint32_t refs;          // 引用计数，生成字符串时置 1 ，表示对自身的引用。减到 0 时释放内存
        uint32_t offset;        // 切片在源串的偏移位置
    };

    union {
        char_t        buf[4];   // 单字节字符数据内存区，包含结尾的 NUL 字符
        struct NSTR * ent;      // 指向被引用的字符串实体，其 buf 与 offset 相加得到切片所在内存起点位置
    };
} nstr_t;
```
