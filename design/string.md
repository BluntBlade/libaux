# 字符串模块

## 需求
字符串是最基本的数据类型，应用广泛。C语言对字符串的定义非常原始，逐渐落后于现代软件编程的需要，常常造成不必要甚至是严重的问题（性能、安全等）。设计一种定长、不可变的字符串类型，配以合适的函数，在满足大部分需求的同时，降低对标准C函数的信赖，降低安全问题的发生概率，显得越来越迫切。

## 设计要点
1. 定长：避免频繁统计长度，快速返回串长度或字符数；
2. 不可变：一经生成，字符内容不再变化，如调用函数改变内容将生成新的字符串；
3. 可引用：可返回片段引用（Slice），使用引用计数进行统计和管理。当字符串不再被引用时，自动释放内存；
4. 多种编码：在内部记录字符串所使用的编码格式，调用对应函数进行处理；
5. 极小内存：内存布局尽量紧凑，减少资源消耗。

## 类型定义
内存布局分为两种格式，A)**字符串**表示一个定长的字符串（标志位置0），B)**片段引用**表示对某个字符串片段的引用（标志位置1）。最长均支持 2^18 个ASCII字符。

```
typedef struct NSTRING {
    uint64_t is_ref:1;   // 引用标志位：0 表示字符串，1 表示片段引用。
    uint64_t code:9;     // 编码方案代号。

    union {
        struct {
            uint64_t      refs:18;     // 引用计数，生成字符串时置 1 ，表示对自身的引用。减到 0 时需要释放内存。
            uint64_t      chars:18;    // 按编码方案解释后的字符个数。
            uint64_t      size:18;     // 字符串实际占用的内存字节数。
            const char    buf[0];      // 字符数据内存区。
        } str;
        struct {
            uint64_t      begin:18;    // 片段在源字符串内存区的起始位置（相对于起点的字节数）。
            uint64_t      chars:18;    // 按编码方案解释后的字符个数。
            uint64_t      size:18;     // 片段实际占用的内存字节数。
            const char *  buf;         // 字符数据内存区，与 begin 相加得到片段所在内存起点位置。
        } slice;
    };
} nstr_t;
```
